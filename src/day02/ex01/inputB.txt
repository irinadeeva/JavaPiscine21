Курс
Задачи
Опросы
Игры
Помощь
График пинков
Стажировка
Сообщество
Пользователи
Форум
Чат
Статьи
Истории успеха
Активности
Отзывы
Подписки



ОТЗЫВЫ
О НАС
CS50
НАЧАТЬ ОБУЧЕНИЕ
Карта квестов
Лекции
CS50
Android
Java Syntax Pro
BufferedReader/InputStreamReader
Java Core
9 уровень, 6 лекция
ДОСТУПНА
— Привет, Амиго! Ты уже давно пользуешься классами BufferedReader и InputStreamReader. Теперь давай разберемся, что же они делают.

Класс InputStreamReader является классическим адаптером от интерфейса InputStream к интерфейсу Reader. Тут даже и добавить нечего.

Но вкратце, происходит вот что. Когда ты запрашиваешь (читаешь посредством read) у объекта типа InputStreamReader очередной символ, он читает из переданного ему в конструктор InputStream-а несколько байт и возвращает их как один char.

Но Reader – не самый удобный объект для работы. Нам часто нужно прочитать не все введенные пользователем символы за один раз, а разбить эти символы на строки.

— Но у класса Reader ведь есть метод read(CharsetBuffer s), разве мы не можем использовать его?

— Этот метод читает данные куском, размер которого равен размеру буфера и помещает их в объект CharsetBuffer.

Текст обычно делится на строки (линии, line — строка по-английски). Поэтому метод read(CharsetBuffer s) может прочитать несколько «линий» за один раз. Если же нам нужно прочитать текст именно до конца «линии» (т.е. все символы строки до enter), для этого лучше поискать что-нибудь еще. И такой метод есть. В классе BufferedReader.

Класс BufferedReader, являющийся удобной надстройкой над Reader, имеет один очень удобный метод: readLine(). Этот метод позволяет читать из Reader-а сразу целыми строками (т.е. линиями). Когда ты в своем коде вызываешь метод readLine, он читает из объекта Reader символы, пока не встретится enter. Как только enter встретится, метод склеит символы в одну строку и вернет ее.

— Я этим постоянно пользовался, только не знал как все это работает. Теперь знаю. Спасибо, Ким.
Предыдущая лекция
Следующая лекция

+163

Комментарии (100)
популярные
новые
старые
ДЛЯ ТОГО, ЧТОБЫ ОСТАВИТЬ КОММЕНТАРИЙ ВЫ ДОЛЖНЫ АВТОРИЗОВАТЬСЯ
Lycurgus
Уровень 29, Казахстан
23 июня, 21:25
Вот серьезно???? Если прям так лень лекции писать, лучше ссылку оставляйте для чего-то полезного. Лишь бы вставить что-то. И совсем не важно, что мы давно уже знаем это.

+2

Jer0me
Уровень 30, Екатеринбург, Россия
12 июня, 17:12
Сначала дают лекцию на  Reader/Writer, но в задачах к этой лекции нужно использовать FileReader! Пока решал, вроде и понятно было, что он нужен, но ведь видел, что это только в следующей лекции, поэтому упорно ломал голову, как обойтись без него... В итоге сдался и решил подсмотреть в правильное решение, и что я вижу? Файл мать его Ридер!!!
Ладно, переходим дальше, лекция про FileReader/FileWriter, начинаем решать задачи.... и в половине задач в условиях: "Программа должна считывать содержимое первого файла (используй BufferedReader c конструктором FileReader)".
Ладно, задачи кончились... И вдруг нам решили про него рассказать, да ладно, надо же, как вовремя то!

+2

Сергей
Уровень 19
25 июня, 09:26
я не смотрел готовые решения предыдущего блока, но там задачи элементарные и решаются как раз проще всего через readLine(). Все NIO я изучал задолго до этого ибо. Тут так, практикуюсь по задачкам, для разминки пока Спринг осваиваю. А если человек не знает теории, то получается ему сначала дали задачу, а потом рассказали в следующей лекции как надо их делать?

0

Anonymous #2297535
Уровень 22, Северодвинск, Россия
11 марта, 21:25
Класс BufferedReader, являющийся удобной надстройкой над Reader, имеет один очень удобный метод: readLine().

"Да что ты говоришь!! Да ладно!! Вау!!! Это так неожиданно!!"

+6

Maks Panteleev
Уровень 33, Москва, Россия
15 апреля, 14:05
Эту бы информацию да уровней 100500 назад....

0

Darth Nihilus
Разработчик спокойствия в Rage&Flame Industrie
8 февраля, 23:01
gnl...

0

Даниил Александрович
Уровень 35, Тамбов , Россия
8 февраля, 20:22
не вижу особого смысла в этих всех обертках.
 кроме как пользы от чтения utf-16 и то с натяжкой.

файлы нужны для логов. для остального есть sql.


0

Петр
Уровень 25, Санкт-Петербург
26 апреля, 16:53
а что такое лог?

0

Даниил Александрович
Уровень 35, Тамбов , Россия
26 апреля, 18:28
Файл регистрации (протокол, журнал, лог; англ. log) — файл с записями о событиях в хронологическом порядке, простейшее средство обеспечения журналирования. Различают регистрацию внешних событий и протоколирование работы самой программы — источника записей (хотя часто всё записывается в единый файл).

0

Никита Куликов
Уровень 22, Владивосток, Россия
10 июня, 08:34
никто в энтерпрайз программировании не использует все эти классы, все работают с готовыми библиотеками logback, log4j, SLF4J. Правда иногда эти либы чудят, приходится смотреть их исходники и адаптировать под них свой код.

0

Алексей
Уровень 25, Night city
3 января, 12:53
Если я правильно понял хочешь читать байты используй InputStream, если символы InputStreamReader, хочешь читать строками - BufferedReader.

0

goodmanmd
Уровень 31, Санкт-Петербург
6 января, 06:56
Не совсем так:
Про InputStreamReader  и  FileReader и в чем разница:

Во-первых, InputStreamReaderможет обрабатывать все входные потоки, а не только файлы. Другими примерами являются сетевые подключения, ресурсы пути к классам и файлы ZIP.
Во-вторых, FileReader до тех пор, пока Java 11 не позволяла вам указывать кодировку символов и вместо этого использовал только кодировку платформы по умолчанию.
В третьих в FileReader  есть конструкторы для работы с файлами.

Что использовать при чтении строк, а что использовать про чтение символов?:
И там и там правильней использовать буфер.
Суть буферов - будь то BufferReader или BufferWriter, BufferInputStream /OutputStream уменьшить кол-во обращений к источнику. так как это дорогостоящий процесс.
А где же буфер? Когда мы пишем :
BufferedReader reader = new BufferedReader(new FileReader("..."));

мы вызываем другой конструктор public BufferedReader(Reader in, int sz) и автоматически создаётся дефолтный массив-буфер чаров, размером defaultCharBufferSize = 8192 :
/**
  * Creates a buffering character-input stream that uses a default-sized
  */
 public BufferedReader(Reader in) {
     this(in, defaultCharBufferSize);
 }


А когда использовать Buffer?Из описания к классу BufferedReader:
In general, each read request made of a Reader causes a corresponding read request to be made of the underlying character or byte stream. It is therefore advisable to wrap a BufferedReader around any Reader whose read() operations may be costly, such as FileReaders and InputStreamReaders.
Резюмируя:
При записи/чтении посимвольно или чтении/записи  строк  - лучше использовать буферы, тем самым уменьшать кол-во системных вызов к файлу к минимуму.
При чтении/записи небольшой информации - можно обойтись  и без буфера.

+29

Deniska
Ученик чародея в тредевятом царстве
24 декабря 2020, 11:18
никогда такого не было и вот опять!  как же я этим пользовался не зная?

+6

Е К
Уровень 37, Краснодар, Россия
15 декабря 2020, 00:35
Core близится к финалу.
У кого пробелы в теории и сложности с практикой, рекомендую лекции по IO #12 - 14 от мистера Иван Головач.
У парня преподавательский талант. Низкий ему поклон - разложил мне всё по полочкам)

+7

Herman Kudria
Уровень 24, Poznan, Польша
5 марта, 15:07
Можете ссылку дать?

0

Е К
Уровень 37, Краснодар, Россия
7 марта, 16:33
Держи

Но как бып пора бы уже и гуглить научиться... или привычка на чужом горбу?

0

Herman Kudria
Уровень 24, Poznan, Польша
9 марта, 16:07
Спасибо, из того что я нашел не было разделение на части свыше 4х.

0

Е К
Уровень 37, Краснодар, Россия
10 марта, 08:20
👍

0

Вадим Илларионович
Java Developer в ЛАНИТ
16 марта, 00:40
Пасивный агресор...

+1

Е К
Уровень 37, Краснодар, Россия
16 марта, 01:08
От нехватки общения что ли?))
😉

0

Евгений
Уровень 20, Краснодар, Россия
23 октября 2020, 21:40
Этот "Enter" - обычно два символа. Один - конец строки, а второй перевод на новую строку. Здесь покачто не знаю как. Бывает просто один перевод на новую строку. Но обычно два символа. И это нужно знать разработчику работающему с символами.

+3

Антон
Full Stack Developer
5 ноября 2020, 22:57
Бывают три вида разделителя строки т.к. нет единого стандарта и в разных OS используют разные варианты: CRLF, CR, LF  (\r\n, \r, \n)

в java можно использовать System.lineSeparator();

P/S: лайк на кармане всегда приветствуется 😉

+12

Pig Man
Главная свинья в Свинарнике
8 ноября 2020, 19:08
It returns "\n" on UNIX System
It returns "\r\n" on Windows System

+2

Андрей
Уровень 25, Москва, Россия
EXPERT
11 ноября 2020, 22:47
В BufferedReader.readLine() реализована проверка на оба варианта. В целом реализация метода не сложная, а решает сразу кучу проблем.

+2

Vgoose
Уровень 20, Москва, Россия
18 ноября 2020, 19:54
Дополню:
CR - carriage return - возврат каретки - возврат в начало строки (пошло от печатных машинок и терминалов с бумагой)
LF - line feed - новая линия - перевод строки

+4

Svetlana Vydrina
Уровень 23
8 октября 2020, 18:16
На человеческом языке ваша «линия» называется «абзац» 🤣

0

Андрей
Уровень 26, Иркутск, Россия
16 октября 2020, 12:37
скорее "строка"

+7


Показать еще комментарии
ОБУЧЕНИЕ
Регистрация
Курс Java
Помощь по задачам
Цены
Задачи-игры
СООБЩЕСТВО
Пользователи
Статьи
Форум
Чат
Истории успеха
Активности
О НАС
О нас
Контакты
Отзывы
FAQ
Поддержка
ПОДПИСЫВАЙТЕСЬ
ЯЗЫК ИНТЕРФЕЙСА

Русский
VisaMastercard
© 2021 JavaRush
Программистами не рождаются
